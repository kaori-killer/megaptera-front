# TypeScript

## :whale2: 키워드

* TypeScript란?
* 데이터 타입이 왜 필요한가?
* TypeScript는 왜 필요한가?
* TypeScript의 특징
* TypeScript 예제
* 모든 데이터의 타입을 명시해야 하는 가?
* type vs interface
* Union 타입
* undefined가 아닌, Optional Parameter
* 타입을 확장하는 방법, Intersection Type
* Tuple

## TypeSciprt란?

TypeScript는 정적으로 데이터 타입을 확인을 제공하는 컴파일 언어입니다.

## 데이터 타입이 왜 필요한가?

JavsScript의 모든 값은 데이터 타입을 갖습니다. 데이터 타입이 필요한 이유는 크게 3가지입니다. 첫 번째, 값을 저장할 때, 메모리 공간의 크기를 확보하기 위해서 입니다. 데이터 타입에 따라 확보해야 하는 공간이 다르기 때문에, 데이터 타입으로 메모리 공간의 크기를 확보하면 낭비와 손실을 줄일 수 있습니다. 두 번째, 값을 참조할 때, 한 번에 읽어야 할 메모리 공간의 크기를 결정하기 위해서 입니다. 이를 알아야 값을 훼손하지 않고 읽을 수 있습니다. 예를 들어, 숫자 타입은 8byte 단위로 읽습니다. 세번째, 메모리에서 읽어 들인 2진수를 어떤 데이터 타입으로 해석할지 결정하기 위해서 입니다.

## TypeScript가 왜 필요한가?

C나 Java는 정적 타입 언어이고, JavaScript는 동적 타입 언어입니다. 정적 타입 언어는 데이터 타입을 변수 선언 시점에 선언합니다. 이후에는 타입을 변경할 수 없습니다. 하지만 동적 타입 언어는 변수 할당 시점에 타입을 결정합니다. 그리고 재할당에 의해 자유롭게 데이터 타입이 변경됩니다. 그래서 동적 타입 언어는 변수 값을 추적하기 어렵고, 타입을 확신할 수 없으며 암묵적 타입 변동에 의해 잘못된 예측을 하기 쉽습니다. 그래서 TypeScript가 도입되었습니다. TypeScript는 정적으로 데이터 타입 확인을 제공하는 언어입니다. 런타임 시점 이전에 타입을 확인해서 오류를 방지합니다.

## TypeScript 특징

TypeScript에서 사용한 타입 정보는 JavsScript로 변환되며 제거됩니다. JavaScript는 동적 타입 언어이기 때문입니다.

## TypeScript 예제

문자열 타입과 숫자 타입을 적용한 예제입니다. `name`과 `age`는 적용된 타입 이외의 값을 넣으면 오류가 발생합니다.

```typescript
let name: string;
let age: number;

name = '홍길동'
age = 13;
```

객체 타입을 적용한 예제입니다.

```typescript
let human: {
    name:string
    age:number    
} = { name: '홍길동', age: 13 }
```

타입으로 정의하면 재사용을 할 수 있습니다.

```typescript
type Human = {
    name: string;
    age: number;
}

let human: Human = { name: '홍길동', age: 13}
```

## 모든 데이터의 타입을 명시해야 하는 가?

아닙니다. TypeScript가 데이터 타입을 추론할 수 있다면 명시적으로 작성할 필요가 없습니다. 다음 예시에서도 return 타입으로 void를 명시할 필요가 없습니다.

```typescript
function printHello(){
    console.log("Hello");
}
```

## type vs interface

타입에서 특정한 값으로 범위를 제한할 때 Union 타입을 씁니다. 
문자열 타입에서 특정 문자열로 값을 제한할 때로 예를 들면 `"red" | "blue" | "yellow"` 이와 같이 쓸 수 있습니다.

```typescript
type Team = "red" | "blue" | "yellow";
type Health = 1 | 5 | 10;

type Player = {
    name: string,
    team: Team,
    health: Health
}

const hong: Player = {
    name: '홍길동',
    team: "red",
    health: 5
}
```

interface는 객체의 모양을 특정해주기 위한 오직 한 가지 용도로 사용합니다. 그래서 `interface Team = "red" | "blue" | "yellow";` 는 불가능합니다. 
그에 비해 type 키워드는 모든 걸 할 수 있습니다.

```typescript
type Team = "red" | "blue" | "yellow";
type Health = 1 | 5 | 10;

interface Player {
    name: string,
    team: Team,
    health: Health
}

const hong: Player = {
    name: '홍길동',
    team: "red",
    health: 5
}
```

## undefined가 아닌, Optional Parameter

Optional Parameter는 함수를 호출할 때 파라미터를 생략할 수 있게 하는 문법입니다.
파라미터 이름 뒤에 ?를 붙이면 됩니다. 다음 예시에서는 파라미터 name을 생략했습니다.

```typescript
function greeting(name?: string): string {
    return `Hello, ${name || `world`}`;
}

greeting(); // Hello World
```

기본 값을 잡아주면 더 좋습니다.

```typescript
function greeting(name: string = 'world'): string {
    return `Hello, ${name}`;
}

greeting(); // Hello World
```

## 타입을 확장하는 방법, Intersection Type

두 개 이상의 타입을 합쳐서 하나의 타입을 만들 수 있습니다.

```typescript
type Human = {
    name: string;
    age: number;
}

type Creature = {
    hp: number;
    mp: number;
}

type Person = Human & Creature;
```

## Tuple

튜플은 배열보다 깐깐하게 타입을 관리하고 싶을 때 사용합니다.
any 타입은 TypeScript 보호장치를 해제합니다. 어떤 타입이든 가능하게 만듭니다.

```typescript
let anytings: any[] = ['홍길순', 13] 

let person: [string, number] = ['홍길동', 13]; 
```
