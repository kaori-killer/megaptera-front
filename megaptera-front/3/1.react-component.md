# React Component

복잡한 앱을 만들더라도 끝까지 적용되는 원칙들이다.

용어의 정의(정확한 정의)
역사 또는 왜 필요한가/왜 생겼는가
특징(또는 장/단점)
실제 사용 사례나 경험

## :whale2: 키워드

* Mockup
* Json
* API
* REST API
* GraphQL
* DSL
* React component
* React props
* SRP(단일 책임 원칙)
* CSS
* Design's Layer
* Atomic Design
* Thinking In React
* Tip

## Mockup이란?

최종 결과물은 아니지만 css나 무언가로 꾸며도 현재 상태에서 크게 바뀌진 않는 결과물이다.

## JSON은 왜 생겼는가?

프론트엔드와 백엔드는 데이터를 교환해야 한다. 하지만 백엔드에서 뭔가를 만들면 그대로 보낼 수 없다. 만약, HTTP를 사용하면 문자열로 보낼 수 있다. 하지만 우리는 문자열이 아니라 객체로 쓰고 싶다. 그래서 등장한게 JSON이다.

JSON은 기본적으로 문자열이지만 stringify, parse를 이용해서 문자열과 객체의 상호 전환이 가능하다.

## API란?

API는 서버와 통신하기 위해 만들어진 인터페이스이다. 프론트와 백엔드의 통신은 API를 이용하여 이루어진다.

백엔드에서 JSON 형태의 데이터를 돌려주는 API를 제공한다고 가정한다면, 대부분 REST API 또는 GraphQL을 쓴다.

## REST API란 무엇인가?

REST는 매번 새로운 URL을 생성하는 방식이다. REST API는 여러 개의 고유한 URL을 활용하여 작동한다. 그리고 이는 각기 다른 데이터를 제공한다.

> 생활코딩 URL를 보니 REST APT를 쓰나보다. `https://www.opentutorials.org/course/5063`

REST API는 웹 사이트를 주는 것이 아니다. URL에 접속하면 브라우저가 데이터를 요청해서 JSON 형태의 데이터를 받는다.

이는 fetch API을 이용해서 HTTP methods(GET, POST, PUT/PATCH, DELETE)로 CRUD를 요청한다. (Resoucrce 중심으로 조작한다.)

## GraphQL이란 무엇인가?

그래프 자료구조 이용한다. 쿼리에서 얻고자 하는 것을 지정한다.

Query(Read),
Mutation(Command: Create, Update, Delete),
Subscription(Event)

## GraphQL은 왜 등장했는가?

REST API의 단점(Over Fetching, Under Fetching)을 극복하고자 등장했다.

### REST API의 단점: Over Fetching

필요한 데이터보다 더 많은 데이터를 가져오는 것이 단점이다.

> 실제로 공공 영화 API를 가지고 웹 사이트를 만들었는데 제목, 평점, 줄거리를 제외한 데이터는 필요 없었다. 때문에 로딩 시간도 길어졌다.

GraphQL은 필요한 정보만 특정하여 가져올 수 있다. QL, 쿼리 언어이니까. 가져올 데이터가 크지 않으면 로딩 시간을 줄일 수 있다.

다음과 같이 작성한다.

```bash
{
    upcoming{
        title
    }
}
```

### REST API의 단점: Under Fetching

반대로 필요한 데이터보다 적은 양의 데이터를 가져오는 것도 단점이다.

> 영화 API에서 개봉 예정 영화와 상영 중인 영화의 데이터를 가져오고 싶은데, URL이 다르다면 2개의 URL에 요청을 해야 한다. 이는 또 로딩 시간 증가로 이어진다.

GraphQL은 1개의 쿼리에 여러 개의 정보를 한방에 요청할 수 있다.

```bash
{
    upcoming{
        title
    }
    nowplaying{
        title
        popularity
    }
}
```

## REST API vs GraphQL

> GraphQL의 등장 배경을 보면 REST API보다 빠르고, Fetch 필요없이 Query로 데이터를 불러올 수 있어서 만능처럼 보인다. 하지만 JSON 데이터가 추가되면 REST API는 그냥 다 가져오는데, GraphQL은 쿼리를 다시 작성해야 하는 문제가 있을 듯 싶다. 특정 필드만 가져오는 상황이면 GraphQL 쓰고 그 외의 상황이면 장단점을 고려해서 선택해야겠다.

## DSL이란?

프론트는 받은 JSON 데이터를 사용자가 볼 수 있도록 UI를 구성한다. 리액트는 선언형으로 UI를 구성할 수 있다. 리액트가 선언형인 이유는 HTML과 유사한 모양의 DSL을 사용하기 때문이다.

DSL은 특정 도메인을 해결하도록 설계된 언어이다. 특정 도메인은 특정 전문 지식 또는 응용 분야를 나타낸다. (웹 개발, 의료, 금융 등) 예로 HTML은 웹 페이지 구조와 내용을 설명하는 데 사용되는 DSL이다.

## 명령형 프로그래밍 vs 선언형 프로그래밍

명령형 프로그래밍은 `어떻게 그것을 해결할 것인가`에 관심이 있다. 이에 C, Java, Pythond 등이 해당한다.

선언형 프로그래밍은 `무엇을 해야 할지를 나타내야 하는가`에 관심이 있다. 이에 HTML, CSS, SQL 등이 해당한다.

> 저번 주차에서 `VDOM은 선언적 API가 가능하게 한다`라고 했다. JSX가 React.createElement로 변환되고, 이를 통해 생성된 리액트 엘리먼트를 이용해 VDOM이 만들어지고, 화면에 그려지기까지.. 나는 아무것도 관여하지 않았다. 선언만 했을 뿐이다. 모두 리액트가 알아서 처리를 했다. 그래서 React 역시 선언형 프로그래밍이라고 하는 것 같다.

## 리액트의 강력한 특징은?

1. 선언형이다.
2. 컴포넌트 기반이다.

리액트의 강력한 특징 중 하나는 컴포넌트 기반이라는 것이다. 단순한 컴포넌트로 복잡한 UI를 만들 수 있다.

> 복잡한 컴포넌트를 만들고 있다면 `리액트의 장점을 못 살리고 있었구나`라고 생각하면 되겠다.

## 단순한 컴포넌트의 기준은?

> 홀맨님: 우선은 너무 지엽적인 거에 집중하기보단, SRP가 필요한 이유를 최대한 느껴보고, 컴포넌트가 어느 수준까지 가벼워 질 수 있는지와 그렇게 했을 때 얻어지는 장점을 생각하세요. 와 나도 꼭 지켜야겠구나! 이런 느낌을 얻어가는게 훨씬 좋습니다.

### 1. SRP (단일 책임 원칙)

'한 가지 일을 잘 해내자'는 사고방식으로 객체 지향 프로그래밍의 5가지 원칙 중 1가지이다.

컴포넌트가 너무 커지고 있다면 쪼개야 한다. 왜냐하면 하나의 컴포넌트가 변경되는 이유는 단 하나여야 하기 때문이다. (= 모든 컴포넌트는 하나의 책임만 가지고
캡슐화 해야 한다. )

캡슐화는 서로 연관있는 속성과 기능들을 하나의 캡슐로 만들어 데이터를 외부로부터 보호하는 것이다.

> SRP원칙을 몰랐을 때는 어떤 기준으로 길어진 함수를 분리해야 할지 몰랐다. 작게 나누면 너무 작은게 아닌가 고민했었다. 그런데 테스트 코드를 작성해보니 하나의 함수에 여러가지 이상의 기능이 들어가면 테스트 코드를 작성하기가 어려웠다. 지금 생각해보면 SRP 원칙을 지키지 않아서 그런 것 같다.
> SPR을 적용하면, 비슷한 무언가를 만들 때 하나의 컴포넌트만 바꿔도 원하는 것을 만들 수 있는 장점이 있는 것 같다.
> 하지만 모든 것은 양날의 검이 아닐까, 작은 컴포넌트가 많아져서 조합의 수가 폭발적으로 많아지면 같은 UI를 구현하더라도 같은 컴포넌트를 쓰지 않아서 통일성이 떨어질 듯 싶다.  
> 추가로, 아샬님이 컴포넌트에 html 또는 자바스크립트 코드가 많아질 수도 있는데 자바스크립트 코드가 많아진다면 SAP가 아닌 다른 방법을 해보라고 하셨다. 아직은 어떤 방법을 이야기 하시는지 모르겠다.

### 2. CSS

이미 알고 있는 기준을 재활용한다. 이게 무슨 말이냐면, 우리는 CSS를 작성할 때 다음과 같이 컴포넌트를 분리하고 있다.

```html
<div class="product">
    <div class="thumbnail">
    <div class="price">
</div>
```

html 코드가 많아지는 경우에는 class 이름을 활용할 수 있다.

### 3. Design's Layer

디자인을 만들 때부터 레이어라는 개념으로 나누어 놓는다. 체계적인 레이어는 트리 형태로 되어 있다. 이를 컴포넌트로 활용할 수 있다.

### 4. Imformation Architecture

API에서 받아오는 데이터(JSON Schema) 기준으로 컴포넌트 구조를 JSON이 체계적으로 되어 있다면 이 구조를 이용한다. 이것에 맞춰 컴포넌트를 나누다보면 자연스레 SRP를 달성하게 되는 흐름인된다.

> 아샬님은 이 방법을 가장 많이 쓰는데, JSON 구조가 체계적이지 않다면 백엔드에서 고치거나 받은 JSON을 고쳐서 사용한다고 하신다.

### 5. Atomic Design

`우리는 페이지를 디자인하는 것이 아니라 구성 요소로 이루어진 시스템을 디자인하는 것입니다.`

추상적인 것에서 구체적인 것으로 넘어갈 수 있는 조립법이다. 우리는 의식적으로 Atomic Design을 생각하지 않았지만, 지금까지 해왔던 방식이었다.

> Button도 재사용할 일이 많아지면 따로 컴포넌트로 빼서 작성했었다. 이게 Atomic Design에 해당한다고 생각하니 신기하다.

### SRP vs Atomic Design

> '한 가지 일만 잘하자'는 SRP이 Atomic Design에도 나온다. 재사용성을 생각한다는 점이 공통점 같은데, 둘은 목표가 다르다.
> SRP는 모듈식 소프트웨어를 설계하기 위한 원칙이고, (아키텍처 설계에 중점)
> Atomic Design는 확장 가능하고 재사용 가능한 UI 구성 요소를 만들기 위한 방법론이다. (사용자 인터페이스 디자인에 중점)

## React Props

컴포넌트를 쪼갤 때 값을 전달해야 하니까 Props를 쓸 수 밖에 없다.

## Thinking in React

Start with the date & mockup

### Step 1: 컴포넌트 계층 구조로 UI를 쪼개라

하나의 컴포넌트 모든 것을 작성하면, 컴포넌트가 비대해지고 다양한 UI가 하나의 컴포넌트에 존재하게 된다.
컴포넌트를 부품으로 생각하고 쪼개서, DOM 트리처럼 컴포넌트 트리(컴포넌트 계층 구조)를 만들어야 한다.

### Step 2: 리액트로 정적인 버전을 만들어라

## map을 사용할 때 키 값을 왜 제공해야 할까?

> 저번 주차에서 배웠 듯이 VDOM을 쓰는 이유 중 하나는 최적화 기법이 있기 때문이었다. `1 2 3 4`가 `2 3 4 5`가 되었을 때 전부 바뀌었다고 생각하지 않고 `1이 빠지고 5가 들어왔네요` 라고 처리한다. 이게 가능했던 이유가 키를 잡아줬기 때문이라, map에서도 최적화를 위해 필수로 키를 요구하는 것 같다.
> 키 값이 없으면 변경 사항을 식별하기 위해 전체 트리를 탐색해야 한다고 한다.

## <React.Fragment>로 작성하는 게 <>보다 나을까?

> <React.Fragment>로 작성하면 키 값을 줄 수 있어서 목록을 렌더링할 때 UI 최적화에 유리한 것 같다.

## interface를 재정의하는 이유는?

```tsx
import Product from "../types/Product";

type FilterableProductTableProps = {
    products: Product[];
}

export default function FilterableProductTable({ 
    products,
 }: FilterableProductTableProps) {
    return( ... )
}
```

> products: Product[]를 그래도 써도 될 거 같은데, 아샬님은 저걸 쓰는 모든 컴포넌트에 인터페이스를 다시 만들어줬다. 생각해보면 아래처럼, 페이지 해당 페이지에서만 쓰기 위한 타입을 위해서(확장을 위해서) 습관처럼 하신게 아닌가 싶다.

```jsx
type FilterableProductTableProps = {
    products: Product[];
} & {}
```

## props를 어떻게 써줘야 할까

> 나는 평소에 다음과 같이 작성해서 props가 많아져도 그냥 주렁주렁 달아서 넘겨줬다. 이 방법은 프로퍼티 하나하나는 고치기는 좋다고 한다.

```tsx
return (
        <>
            {productsInCategory.map((product) => (
                <ProductRow key={product.name} name={product.name} price={product.price} />
            ))}
        </>
)
```

> 개별적 처리가 없으면 아래 방법이 더 낫다고 한다. 아샬님은 다음과 같이 작성하는 것을 더 선호하신다.

```tsx
return (
        <>
            {productsInCategory.map((product) => (
                <ProductRow key={product.name} product={product} />
            ))}
        </>
)
```

## Tip

### 모듈 불러오기 순서

> 아샬님은 모듈을 불러올 때 컴포넌트 먼저쓰고 아래 타입을 쓰신다고 한다.

### input과 label 쓰는 방식

> 아샬님은 1번을 더 선호한다고 한다.

```html
// 1번
 <div>
    <input type="checkbox" id="only-stock" />
    <label htmlFor="only-stock">
        Only show products in stock
    </label>
  </div>

// 2번
  <div>
    <label>
      <input type="checkbox" />
      Only show products in stock
    </label>
  </div>
```

### type vs interface

> 아샬님은 type을 많이 쓰신다고 했는데 다음과 같은 product에는 interface를 사용한다고 하신다.
> 이유는 아직 잘 모르겠다.

```typescript
interface Product {
    category: string; 
    price: string; 
    stocked: boolean;
    name: string;
}
```

## 메모

> 오늘에서야 느낀 점인데, 컴포넌트를 함수나 클래스로 분할한다. 그래서 분할할 때 해당 부분이 기능 중심이라면 함수로 분리해서 util에 넣었다가 호출하고, UI와 관련되어 있다면 컴포넌트로 분할해서 호출하는 것 같다.
