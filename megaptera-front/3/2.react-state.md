# React State

대부분 생각보다 React State에 대해 제대로 모르는 경우가 많다.
상태관리를 논하기 전에 도대체 React State가 무엇인지 명확하게 알아보는 시간을 가져보자.

## :whale2: 키워드

* React state
* DRY
* SSOT(Single Source of Truth)
* useState
* Lifting State Up
* 일급 객체(first-class object)

## Thinking in React

Step 3: UI 상태가 뭔지 찾아라
Step 4: 상태를 어디에 있게 할 것인지 결정해라
Stept 5: 데이터 흐름에 역방향 넣어라

## React의 State란?

변경을 다루기 위한 요소이며 `리랜더링`이란 주제에서 다뤄진다. 어떤 컴포넌트의 state가 바뀌면 해당 컴포넌트와 하위 컴포넌트를 리렌더링하게 된다.

아무렇게나 state를 만들어도 된다. 하지만 일관성과 효율성을 위해서 DRY 원칙을 따르는 SSOT를 만든다.

### DRY 원칙 & SSOT이란? (Single Source Of Truth = 데이터 조각의 단일 소스)

중복배제, 반복하지 마라.

```tsx
function ProductTable({ products }: ProductTableProps){
    const categories = selectCategories(products);

    return(
        ...
    );
}
```

categories는 products가 변경되었을 때, products와 관련되어 있기 때문에 같이 변경해야 한다.
그런데 products를 props로 줬기 때문에 알아서 변경이 된다.

그래서 categories를 처음부터 있게 state로 만들 필요가 없다. 그리고 state에서 값을 꺼내오는 거면 중복으로 데이터를 갖게 돼서 값이 틀릴 수도 있다.

> 리렌더링 된 다음, 값이 setState로 변경 전에 state값을 가져오게 되면 원하는 값이 나오지 않게 될 수도 있다는 말 같다.

## State의 조건은?

모든 데이터가 state가 아니다.

### 1. 변경돼야 한다

변경되지 않는 것은 다룰 가치가 없다. 예를 들어, 서버로 받은 JSON데이터 말고 우리 예제처럼 그냥 쓰는 JSON 데이터는 그냥 props로 내리면 된다.

### 2. props로 받는 것은 state가 될 필요가 없다

얻은 값은 상태로 다룰 필요없다.

### 3. 계산 가능하면 state가 아니다

다음의 1번처럼 쓰면 안된다. effect가 필요는 상황이다. 상태처럼 관리하려고 하면 안된다.

```jsx
// 1번, BAD
const [categories, setCategories] = useState<string[]>([]);

useEffect(() => {
    setCategories(selectCategories(products));
}, [producs]);

// 2번, GOOD
const 어쩌고 = selectCategories(products)
```

## useState란?

useState는 state를 관리할 수 있도록 하는 내장 훅이다.

[상태, 상태를 덮어쓰게 해주는 함수] 구조이다.

```tsx
const [count, setCount] = useState(0);
```

> 1주 차에서 잠깐 언급되었듯이 useState는 Tuple 타입을 갖는다.

```tsx
function useState<S>(initialState: S | (() => S)): [S, Dispatch<SetStateAction<S>>];
```

## 다루는 상태가 많을 때, 어떻게 해야할까?

다루는 상태가 많으면 복잡하다. 타입스크립트를 잘 쓰면 직접 관리하는 상태의 수를 줄일 수 있다.

타입스크립트로 데이터를 잘 모으면 된다. 그래서 props를 한 개만 던지면 된다. 던진 props는 모았을 때 어색하지 않은 잘 정의된 타입 혹은 인터페이스이다.
이렇게 하면 props를 쓰는 것과 비슷하게 된다. 다른 데 넘겨주기가 좋아서, 재사용할 때 부담감이 없어진다.

> 타입스크립트를 리액트에서 잘 쓰는 방법을 계속 고민해보자.

추가로 자바스크립트로 데이터를 모으면 불안하다. 그 안에 뭐가 들어있는지 모르기 때문이다. 그래서 이때는 props로 하나씩 던져주는 게 낫다.

## 상태는 누가 관리(누가 소유)해야 할까?

해당 상태에 의존적인 컴포넌트를 모두 포함하는 최상위 컴포넌트가 상태를 소유해야 한다. 상태가 더 이상 올라갈 필요가 없을 때까지 올려야 하며, 이를 Lifting State UI라고 한다.

## React.ChangeEvent란?

리액트에서 제공하는 이벤트 객체의 모양을 정의하는 것이다.

```typescript
interface ChangeEvent<T = Element> extends SyntheticEvent<T> {
    target: EventTarget & T;
}
```

어떤 태그의 event인지 알려줘야 하기 때문에, `ChangeEvent`의 타입을 `HTMLInputElement`로 잡을 수 있다.
`HTMLInputElement`는 브라우저에서 제공하는 DOM에 대한 타입이다.

```tsx
const handleChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    const { value } = event.target;
    setFilterText(value);
};
```

만약 리액트를 사용하지 않는다면, DOM의 모든 이벤트 대상에 대한 기본 인터페이스인 EventTarget을 확장하면 된다.

```typescript
type InputEvent = {
  target: EventTarget & {
    value: string;
  };
}

const handleChange = (event: InputEvent) => {
  const { value } = event.target;
  setFilterText(value);
};
```

## Inverse Data Flow란?

데이터는 위에서 아래로 흐른다. 함수는 아래에서 위로 흐르면 된다.

하위 컴포넌트의 props로 함수를 전달한다. (하위 컴포넌트에 의해 콜백되기 때문에 콜백 함수라고 한다.)

## 일급 객체란? (first-class object)

자바스크립트의 함수는 일급 객체이다. 함수를 값으로 취급할 수 있어서 props로 전달이 가능한 것이다.

> Deep Dive 책에서도 나왔듯이 함수가 일급 객체이기 때문에 프로퍼티의 값으로 함수를 넣을 수 있다.
