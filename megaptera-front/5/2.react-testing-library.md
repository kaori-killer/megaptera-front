# React Testing Library

## :whale2: 키워드

* React Testing Library
* given - when - then
* Mocking
* Test fixture

## React Testing Library란?

리액트 컴포넌트를 사용자 입장에 가깝게 테스트할 수 있는 도구이다.

> jest가 돌아가는 곳은 노드이다. 웹 브라우저가 아니다. 하지만 document를 쓸 수 있게 지원해준다.
> 아샬은 test 파일은 대상 파일과 같은 곳에 놓는 걸 추천한다. 다른 곳에 놓아도 상관은 없다.

## given-when-then 이란?

BDD의 일부로써 시나리오를 작성하는 것이다.

```typescript
test('TextField', () => {

 // given: 테스트의 전제 조건이다. (준비)
 const setText = () => {}
 
 // when: 행동 (실행)
 render(
 <TextField 
  label=""
  text=""
  setText={setText}
  placeholder=""
 />);

 // then: 행동으로 인해 예상되는 변경 사항 (검증)
 screen.getByLabelText('Search')
})
 ```

`getByLabelText`는 라벨과 연결된 인풋이 잡는다. get은 오케이, 없으면 에러이다.

> 3주차 과제할 때, label을 깜빡하고 안 쓰고 테스트를 돌려서 실패가 나왔다. label이 뭐라고 이게 실패를 만드나 싶었는데, getByLabelText로 인풋을 잡기 때문이었다.

## 컴포넌트 테스트를 하는 이유는?

컴포넌트의 인터페이스를 점검할 수 있다. 테스트를 하기 전, 기존에 있던 문제를 보자.

1. label이 placeholder나 text처럼 값을 받지 않았다.
2. text를 filterText라는 이름으로 사용했다. 인터페이스 측면에서 보면 filterText라는 이름을 쓸 필요가 없다. 범용적인 표현으로 text를 써야 한다.

테스트 먼저 작성했었으면, 작성하기 전이나 직후에 문제를 발견해서 바로 수정할 수 있다.
시간이 지나면 코드에 대한 지식과 자신감이 감소한다. 코드는 점점 건드리기 힘들게 된다. 미리미리 고칠 수 있게 테스트를 작성하자.

```tsx
test('TextField', () => {
  const text = 'Tester';
  const setText = () => {};

  render(
    <TextField
      label="Name" // 1
      placeholder="Input your name"
      text={text}
      setText={setText} // 2
    />,
  );
 ...
});
```

## fireEvent란?

fireEvent 메서드를 사용하면 DOM 이벤트를 실행할 수 있다.

```tsx
fireEvent.change(screen.getByLabelText(label), {
  target: { value: 'New Name' }, // target에 값을 넣는 방법
});
```

## jest.fn

가짜로 구현할 수 있다.

```tsx
test('TextField', () => {
 const setText = jest.fn(); 

expect(setText).toBeCalled(); // Yes 
// jest.fn()로 작성해도 호출된 걸 확인할 수 있다.

expect(setText).toBeCalledWith('New Name'); // Yes
// TextField에서 어떤 값으로 호출했는지 확인 가능
})
```

context마다 반복되는 코드가 있다면 함수로 추출한다.
근데 주의할 점이 context로 나눴는데 동일한 함수를 부를 때, 하나의 목을 사용하면 안된다.
매번 테스트 때마다 초기화를 해주면 괜찮다.

```tsx
 const setText = jest.fn(); 
 beforeEach(() => {
  setText.mockClear(); // 얘만 clear
  
  or

  jest.clearAllMocks(); // 목 잡아놓은 거 다 clear
 });
```

그리고 만약에 입력을 받는데 text가 숫자만 받게 하는 기능이 있다면, 이건 컴포넌트 책임이 아니다.
이는 비지니스 로직에 가까워서 함수를 추출해서 걔가 책임을 가지게 해야 한다.

## Test fixture

테스트에서만 가짜로 쓰는 더미 테이터를 잡아준다.
다음과 같이 작성하면 테스트 한정 `./hooks/useFetchProducts`의 값이 저렇게 잡힌다.

```tsx
jest.mock('./hooks/useFetchProducts', () => () => [
 {
  category: 'Fruits', price: '$1', stocked: true, name: 'Apple',
 },
]);
```

위 처럼 훅을 모킹하는 것을 테스트 코드 내부에서 작성할 수 있지만, 규모가 커지면 복잡해진다.
`hooks/__mocks__ `폴더에서 mocking을 해놓고 외부로 export 하여 사용하면 더 보기 좋다.

## npx tsc --nolint

swc가 타입을 다 빼고 돌린다. 그래서 타입 잘못한 부분을 찾으려면 다음 명령어를 이용한다.

```bash
npx tsc --nolint
```

혹은

```bash
npm run check
```

컴파일 하는 결과가 js파일로 생기지 않게 한다.

## 메모

이번 강의가 지금까지 들은 강의 중에 제일 어려웠다. 계속 반복 훈련면서 연습을 해야겠다.
빡세게 테스트를 잡으면 고쳤을 때 쉽게 깨질 수 있다. 하지만 당연하 해야 한다고 느껴지면 빡빡하게 잡아도 된다.
아래는 screen 관련 함수인데 신기해서 메모한다.

```tsx
screen.getByLabelText(label);
screen.getByPlaceholderText(/name/);
screen.getByDisplayValue(text);
```

숨기지는 않는 편 25:26
