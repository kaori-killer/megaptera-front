# React Testing Library

## :whale2: 키워드

* React Testing Library
* given - when - then
* Mocking
* Test fixture

## React Testing Library란?

리액트 컴포넌트를 사용자 입장에 가깝게 테스트할 수 있는 도구이다.
jest가 돌아가는 곳은 노드이다. 웹 브라우저가 아니다. 하지만 document를 쓸 수 있게 지원해준다. 그래서 사용자 입장에서 가깝게 됐다.

> 아샬은 test 파일은 대상 파일과 같은 곳에 놓는 걸 추천한다. 다른 곳에 놓아도 상관은 없다.

## 컴포넌트 테스트를 하는 이유는?

컴포넌트의 인터페이스를 점검할 수 있다.

테스트를 하기 전, 기존에 있던 문제를 보자.

1. label이 placeholder나 text처럼 값을 받지 않앗다.
2. text를 filterText라는 이름으로 사용했다. 인터페이스 측면에서 보면 filterText라는 이름을 쓸 필요가 없다.

개발하면서 이런 문제를 발견할 수 있지만, 테스트부터 작성했다면 작성하기 전 또는 직후에 문제를 발견해서 수정할 수 있다.
시간이 지나면 코드에 대한 지식과 자신감이 감소한다. 코드는 그렇게 건드리기 힘든 코드가 된다.

```tsx
import { render, screen } from '@testing-library/react';

import TextField from './TextField';

test('TextField', () => {
  const text = 'Tester';
  const setText = () => {
    // ...
  };

  render(
    <TextField
      label="Name"
      placeholder="Input your name"
      text={text}
      setText={setText}
    />,
  );

  screen.getByLabelText('Name');
});
```

## 반복되는 코드는 추출하자

비지니스 로직같은 부분, 예를 들어서 input에 숫자만 입력 받게 하고 싶다면 이 부분은 외부에서 주입받게 한다.
컴포넌트가 비즈니스 로직의 책임을 갖지 않게 한다. 이렇게 하면 함수가 호출되었는지만 확인하면 된다. (fireEvent 등을 통해 인터랙션만 검증한다.)

## 외부 의존성이 큰 함수는 mocking

테스트를 작성할 때 외부 의존성이 강한 부분이 있다면 가짜로 구현한다.

일반적으론 백엔드와 소통하는 부분이 차지하는 비중이 큰데,
이 부분을 하나씩 가짜 구현으로 바꾸다 보면 어려울 때가 있다고 한다. 이럴 땐 MSW 등 다른 대안을 고려해 보자.

```tsx
import { render, screen, fireEvent } from '@testing-library/react';

import TextField from './TextField';

const context = describe;

describe('TextField', () => {
  const text = 'Tester';
  const setText = jest.fn();

  beforeEach(() => {
    setText.mockClear();
    // 또는 jest.clearAllMocks();
  });

  function renderTextField() {
    render(
      <TextField
        label="Name"
        placeholder="Input your name"
        text={text}
        setText={setText}
      />,
    );
  }

  it('renders an input control', () => {
    renderTextField();

    screen.getByLabelText('Name');
  });

  context('when user types text', () => {
    it('calls the change handler', () => {
      renderTextField();

      fireEvent.change(screen.getByLabelText('Name'), {
        target: {
          value: 'New Name',
        },
      });

      expect(setText).toBeCalledWith('New Name');
    });
  });
});
```

## flxture

테스트 코드에서 쓰이는 더미 테이터를 의미한다.

hook을 mocking하는 경우에도 처음에는 테스트 코드 내부에서 작성할 수 있지만, 규모가 커지면 복잡해진다.
hooks/__mocks__ 폴더에서 mocking을 해놓고 외부로 export 하여 사용한다.

```tsx
import { render, screen } from '@testing-library/react';

import App from './App';

jest.mock('./hooks/useFetchProducts', () => () => [
 {
  category: 'Fruits', price: '$1', stocked: true, name: 'Apple',
 },
]);

test('App', () => {
 render(<App />);

 screen.getByText('Apple');
```

## 메모

이번 강의가 지금까지 들은 강의 중에 제일 어려웠다. 계속 반복 훈련면서 연습을 해야겠다.

BDD 스타일로 테스트 코드를 작성하는 게 읽기 쉽다. 테스트 코드도 코드이다.
