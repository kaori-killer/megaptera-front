# JSX

## :whale2: 키워드

* XML
* JSX
* Babel
* React
* VDOM
* 재조정

## XML이란?

## JSX란?

JSX는 자바스크립트 파일 안에 HTML과 유사한 마크업을 작성할 수 있는 자바스크립트 확장 문법이다.

## JSX를 왜 써야 할까?

렌더링 로직과 콘텐츠를 같은 위치에 유지할 수 있다. 그래서 마크업 안에 자바스크립트 로직을 추가하거나 동적 프로퍼티를 참조할 수 있다.

기존의 방식은 HTML과 자바스크립트 코드가 분리되어 있어서, 어떤 HTML 태그와 자바스크립트 함수가 서로 관련돠어 있는지 파악하기 어려웠다.
React에서는 마크업과 로직이 함께 있는 컴포넌트를 사용하면서 이러한 관계를 명확하게 파악할 수 있게 됐다.

## JSX는 꼭 리액트에서 써야 하는가?

JSX와 리액트는 별개의 개념이다. 서로 독립적으로 사용할 수 있다.

## JSX의 특징

JSX 코드는 바벨과 같은 도구를 이용해 표준 ECMA 자바스크립트 코드로 변환된다.

자바스크립트 코드와 일대일로 매칭된다.

## JSX 규칙

### 단일 루트 엘리먼트 반환

JSX는 다음과 같이 작성할 수 `없`다.

```jsx
  <p>Hello, world!</p>
  <Button type="submit">Send</Button>

  <>
    <p>Hello, world!</p>
    <Button type="submit">Send</Button>
  </>

  React.createELement(
    React.Fragment,
    null,
    React.createElement('p', null, 'Hello, world!'),
    React.createElement('Button', {type: "submit"}, 'Send'),
  )
```

이유는 React Element는 React.createElement를 실행하기 위해 1개의 부모만 가질 수 있기 때문이다.

`<div>` 같은 태그로 감싸주고 싶지 않거나 DOM에 태그를 삽입하고 싶지 않다면 Fragement `<></>`를 이용한다.

```jsx
<div className="test">
  <p>Hello, world!</p>
  <Button type="submit">Send</Button>
</div>;

React.createElement(
  'div',
  { className: 'test' },
  React.createElement('p', null, 'Hello, world!'),
  React.createElement(Button, { type: 'submit' }, 'Send'),
);
```

### 모든 태그 닫기

태그가 비어있다면 XML처럼 />를 이용해 바로 닫아야 한다.

```jsx
<br></br>

혹은

<br />
```

## JSX 객체 표현

JSX는 객체를 표현한다. 변환기 중 제일 유명한 바벨로 확인 가능하다.

바벨은 JSX를 React.createElement() 호출로 컴파일해서 자바스크립트로 변환한다.

```jsx
<Button type="submit">Send</Button>;
```

위 코드는 다음과 같은 객체를 생성한다.

```javascript
React.createElement(Button, { type: 'submit' }, 'Send');
```

JSX를 리액트 외부에서 사용하고 싶을 때는 다음과 같이 @jsx를 추가한다.

```jsx
@jsx r.createElement

<Button type="submit">Send</Button>;
```

### 카멜케이스

속성은 자바스크립트 객체의 키가 된다. 이는 카멜케이스로 작성한다.

예를 들어, class는 HTML 속성이름이다. 즉, 예약어이다. 그래서 카멜케이스로 className이라고 작성한다.

```jsx
<img 
  src="https://i.imgur.com/yXOvdOSs.jpg" 
  alt="Hedy Lamarr" 
  className="photo"
/>
```

### 태그 안에 공백

JSX는 태그 안에서 text와 자바스크립트 값으로만 구분을 한다.

공백을 사용하려면 {' '} 이렇게 createElement에 추가해야 된다.

```jsx
<div>
  <p>Count: {' '} {count}!</p>
  <button type="button" onClick={() => setCount(count + 1)}>
    Increase
  </button>
</div>;

React.createElement(
  'div',
  null,
  React.createElement('p', null, 'Count: ', ' ', count, '!'),
  React.createElement(
    'button',
    { type: 'button', onClick: () => setCount(count + 1) },
    'Increase',
  ),
);
```

## React 엘리먼트

createElement로 생성한 객체를 React 엘리먼트라고 한다.

화면에서 보고 싶은 것을 나타내는 표현이다. 리액트는 이 객체를 읽어서 DOM을 구성하고 최신 상태로 유지하는데 사용한다.

불변 객체라서 생성한 이후에는 자식이나 속성을 변경할 수 없다.

## DOM에 Rect 엘리먼트 렌더링

UI를 업데이트 하는 유일한 방법은 새로운 엘리먼트를 생성하고 root.render로 전달하는 것이다.

리액트 DOM은 해당 엘리먼트와 그 자식 엘리먼트를 이전의 엘리먼트와 비교한다. 그리고 DOM을 원하는 상태로 만드는데 필요한 경우에만 DOM을 업데이트 한다.

## VDOM (Virtual DOM)

가상의 DOM이다. React에서는 바로 DOM을 조작하지 않는다. Virtual DOM 트리를 만들어서 사용한다.

![ex\_screenshot](./img/vdom.png)

## 재조정 공신문서를 읽어보렴

실제 DOM과 동기화를 하는 과정이 재조정이다.

이 과정에서 VDOM은 Real DOM과 비료하면서 바뀐 부분만 변경한다.

## VDOM을 쓰는 이유

VDOM을 쓰면 일을 2번 하는 것이다. DOM에 바로 반영하지 않고 VDOM을 쓰는 이유는?

돔보다 빠르다. 미신임.

핵심은 유지보수가 가능한 어플맄에션을 만드는 걸 도와줌. 충분히 빠르다.

VDOM DOM
홍  홍
기  길
동  동

홍  홀
기  기
동  동

## 리액트에서 성능 최적화

깐깐체크 strictmode 두번 돌려서 두개가 다르다? 너 사이드 이팩트가 쎼다.

잘 짜면 재조정을 막하지 않음

## 메모

