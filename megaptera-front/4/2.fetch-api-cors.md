# Fetch API & CORS

백엔드에서 API 스펙은 잡혀있으나 안 나왔을 때, 데이터를 한 번 정제하고 싶을 때 기다리지 않고 정적인 데이터라도 구성해서 진행할 수 있다.

## :whale2: 키워드

* Fetch API
* Promise
* ReableStream
* Unicode
* CORS

## Promise란?

자바스크립트는 싱글 쓰레드이기 때문에 비동기 작업을 수행한다. 비동기 작업은 현재 작업이 끝날 때까지 기다리지 않고 다음 작업을 수행하는 방식이다.
하지만 연속되는 비동기 함수를 처리할 때, 비동기 함수의 결과 값을 다음 비동기 함수의 인자로 사용하기 위해서 콜백 지옥이 나타날 수 있다.

이를 해결하기 위해서 프로미스가 등장했다. 프로미스는 자바스크립트의 비동기를 돕는 객체이다.

프로미스 객체를 반환하는 함수는 비동기적으로 동작한다. 프로미스 객체는 바로 사용할 수 없다. pedding 상태이기 때문이다.
then 메소드 혹은 async/await 문법을 사용하면 비동기 처리가 끝난 후의 값을 받아올 수 있다. 이를 이용해 값을 사용한다.

```javascript
fetch('http://localhost:3000/products');
// → Promise 반환

await fetch('http://localhost:3000/products');
// → Response 반환
```

then으로 연결하면 더 이상 콜백 지옥이 필요없다. (프로미스 체이닝)

## async & await이란?

프로미스를 더 쉽고 가독성있게 작성할 수 있다.

async를 함수 앞에 붙이면 프로미스 객체를 반환하는 비동기 함수가 된다.
await은 비동기 함수의 호출 앞에 붙이면 비동기 함수가 동기적 함수처럼 동작한다. 이는 async 함수 내에서만 붙일 수 있는 키워드이다.

## Fetch

fetch는 API 호출을 돕는 내장함수이다. 그리고 프로미스를 반환하는 비동기 함수이다.
then으로 API의 결과 값을 확인해보면 JSON 값을 주는게 아니라, 객체 자체를 반환한다.

## Fetch API란?

웹 브라우저에서 사용하는 것이다. 우리는 노드를 이용해서 백엔드를 만들었다. 프론트엔드에서 데이터를 사용해야 돼서 Fetch API를 이용한다.

fetch API는 fetch를 쓴다.

## ReableStream이란?

```javascript
const response = await fetch('http://localhost:3000/products');
// → response의 body가 ReadableStream이다.

const reader = response.body.getReader();

const chunk = await reader.read();
// → Uint8Array(434)  
// chunk의 value는 Uint8Array 타입이다.
// 434은 글자 수가 아니라 데이터가 434바이트를 라는 뜻이다. 
// 데이터가 클 수도 있어서 한 번에 읽히지 않다. 따라서 chunk의 done이 true일 때까지 반복해서 읽어야 한다.

const body = new TextDecoder().decode(chunk.value);
// Uint8Array를 string으로 바뀌기 위한 디코더이다.

const data = JSON.parse(body);
// string → JSON
```

하지만 위처럼 복잡하게 하지 않는다. JSON을 기본 지원한다. 아래와 같이 쓴다.

```javascript
const response = await fetch('http://localhost:3000/products');
const data = await response.json();
```

## 다른 HTTP Method를 쓰고 싶다면?

```javscript
const response = fetch(url, {
    method: 'POST',
});
```

## CORS 에러 발생

다음과 같이 fetch로 API를 불러오면

```tsx
async function main() {
    const url = 'http://localhost:3002/products';
    const response = await fetch(url);
    const data = await response.json();
    const {products} = data;

    console.log(products);

    const element = document.getElementById('root');
}

main();
```

CORS 에러가 발생한다.

```javascript
calhost/:1 Access to fetch at 'http://localhost:3002/products' from origin 'http://localhost:8080' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource. If an opaque response serves your needs, set the request's mode to 'no-cors' to fetch the resource with CORS disabled.
```

## 동일 출처 정책이란?

 동일 출처 정책(Same Origin Policy)은 웹 브라우저가 가지고 있는 보안 정책이다. 같은 곳에서 얻어지는 걸로만 해야 한다는 뜻이다.

예를 들어, 웹 페이지(localhost:8080)와 리소스를 요청한 곳(localhost:3000, REST API 서버)이 서로 다른 출처(포트까지 포함)일 때 서버에서 얻은 결과를 사용할 수 없게 막는다. 브라우저 단에서 막기 때문에 못 쓴다.

하지만 주의할 점이 서버에 요청하고 응답을 받아오는 것까지는 이미 진행이 다 된 상태라는 점이다. (네트워크에서 보면, 상태 코드가 200이다.)
따라서 뭔가 생성이나 업데이트하는 것이라면 이 에러가 뜨더라도 작업이 일어난다.

> 예전에 브라우저에서 Input 태그로 로컬에서 받아서 파일의 URL을 로컬 스토리지에 저장하는 작업을 시도한 적이 있다. 하지만 저장하는 과정에서 파일의 경로가 Fake처리 되었다. 이는 로컬 파일을 건드리는 일 자체가 악성 코드에 노출되는 일이기 때문에 URL을 브라우저가 이렇게 변경한 것이었다. 그레서 다른 출처로부터 로드된 문서를 처리하는 일이 되어 동일 출처 정책에 위반돼 동영상이 나오지 않았다. 해결 방법은 브러우저는 파일 시스템을 제공하지 않기 때문에 방법이 없어서 파이어베이스를 이용해 IndexedDB 사용했더니 해결되었다.

## CORS (Cross Origin Resource Sharing)

Cross Origin이기 때문에 다른 곳이어도 괜찮다는 뜻이다.

```plaintext
브라우저: 그거 문제있어!
(리소스를 주는) 서버: 문제 있다고 했지만, 거기에서 요청한 것은 괜찮아. 쓰게 해줘. (웹 브라우저에게 요청)
브라우저: (헤더를 보고 처리)
```

REST API 서버에서 Headers에 'Access Control Allow Origin' 속성을 추가하면 된다.
디테일 하게 잡을 수 있긴 한데 완전 백엔드니까 우리는 간단하게만 처리한다. Express에서는 그냥 CORS 미들웨어를 설치해서 사용하면 된다.
디테일하게 안하고 *로 해서 어디서 요청하던지 맘대로 쓰게 설정한다.

## CORS 해결하는 방법

### 패키지 설치

```bash
npm i cors
npm i -D @types/cors
```

### CORS 미들웨어 사용

```bash
# 서버의 app.ts

import express from 'express';
import cors from 'cors';

const app = express();

app.use(cors());
```

이제 프론트와 백엔드를 연결할 수 있게 됐다.

```tsx

<App products={products}/>
```
