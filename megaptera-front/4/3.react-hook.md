# React Hook

## :whale2: 키워드

* React Hook
* useState
* useEffect
* useContext
* useRef
* useLayoutEffects
* React StrictMode

## HOC

`재활용하기`이다.

HOC(Higher Order Component)는 고차 컴포넌트이고, 이는 컴포넌트 로직을 재사용하기 위한 React 기술이다.
컴포넌트는 props를 입력으로 받고 UI를 반환하지만, 고차 컴포넌트는 컴포넌트를 입력으로 받고 새로운 컴포넌트로 반환한다.

컴포넌트를 다른 컴포넌트로 감싸고 props로 내려준다.

이에 대한 문제점은

1. 복잡하다.
2. 컴포넌트가 계속 생긴다.
3. 컴포넌트 자체가 커진다.
4. `this는 어떻게 될까요?`처럼 혼란스러운 상황이 발생한다.

컴포넌트 안에 불필요한 것까지 포함해서 이것저것 많이 들어가니까 컴포넌트가 커지는 거다.

## React Hook을 도입하기 전, 기본 방식의 문제점은?

* Wrappre Hell (HOC)
* Huge Components
* Confusing Classes

그리고 클래스로 컴포넌트를 작성하지만 컴포넌트는 객체지향적으로 짜는 게 아니다. 객체지향과 별로 상관없다.

## React Hook이란?

이러한 문제점을 해결하기 위해 React 16.8에서 Hook을 도입했다. 이는 함수 컴포넌트로 리액트 쓰는 방식을 완전히 바꿨다. 이제 함수 컴포넌트에서 훅으로 모든 게 처리가 가능하기 떄문에, 예전으로 돌아가는 건 불가능하다. (하지만 클래스 컴포넌트를 없애버린건 아니다.)

따라서 훅을 사용하면 클래스를 사용하지 않고 state 및 리액트 기능을 사용할 수 있다.

## React Hook 도입하기 전에는 어떻게 작성했을까?

기존에는 상태를 가진 컴포넌트는 클래스 컴포넌트로 만들었다.
그리고 props만 사용하는 순수한 (재사용이 용이하고 작은) 컴포넌트는 함수 컴포넌트로 만들었다.

두 개를 명확히 구분한 것이다.

## React Hook을 도입한 현재는?

* 함수 컴포넌트만 사용한다.

과거에는 클래스 컴포넌트를 썼기 때문에 이는 상태를 관리하는 컴포넌트인 것을 알아차릴 수 있었다.

하지만 현재는 state 훅을 쓰기 때문에 알 수 없다. 그러면 `상태 관리 유무를 바로 알기 어려우면 안 좋은 가?`에 대해 생각해보자. 대답은 `아니다.`이다. 현재는 신경쓰지 않아도 되게 패러다임이 변했다.

* 복잡한 요소는 전부 훅으로 격리 및 재사용 가능하다.

과거에는 HOC로 빼지 않는 이상 컴포넌트 안에 이것저것 들어가 있었다. 복잡했다. 하지만 현재는 훅으올 빼는 게 너무 쉽다. 격리 및 재사용이 너무 쉽다.

## 대표적인 Hook은?

기본 훅

이들은 이렇게 부를 수 있다. 예를 들어, use[State]는 [State] Hook.

* useState: React의 State
* useEffect (Side Effect)
* useContext

추가 훅

* useRef
* useLayoutEffect: useEffect와 같게 동작하지만 실행 시점이 다르다.

## useEffect

### useEffect란?

렌더링 이후에 해야 할 일, 다시 말하면 리액트의 외부와 관련된 일을 정해줄 수 있다.

### useEffect는 언제 쓰는 가?

일부 컴포넌트는 리액트가 아닌 외부랑 동기화를 해줘야 하기 때문에 이펙트가 있다. 이를 사이드 이펙트를 다룬다고 한다.
반대로 말하자면, 외부랑 동기화 하는 경우가 아니면 effect를 쓰면 안된다는 점을 기억해야 한다.

### useEffect는 언제 실행되는가?

기본적으로 렌더링 될 때마다 실행된다. 의존성 배열을 통해 언제 이펙트를 실행할 지 지정할 수 있다.

### useEffect 간단한 예제

document의 title를 바꿔주는 것은 외부랑 동기화하는 것이다. 그래서 아래와 같이 useEffect 안에 작성하는 것이 우아한 방법이다.

```tsx
useEffect(() => {
    document.title = 'xxx';
});
```

### useEffect로 컴포넌트 종료하기

컴포넌트가 없어져도 타이머 기능은 없어지지 않는다.

```tsx
function Timer() {
    useEffect(() => {
        console.log('Effect');

        // 컴포넌트가 화면에서 사라지는 것과 상관없이 0.1초마다 계속 title이 바뀐다.
        setInterval(() => {
            document.title = `Now: ${new Date().getTime()}`;
        }, 100);
    });

    return <p>Playing</p>;
}
```

```tsx
function TimerControl() {
    const [playing, setPlaying] = useState(false);

    const handleClick = () => {
        setPlaying(!playing);
    };

    return (
        <div>
            {playing ? (
                <Timer />
            ) : (
                // Timer 컴포넌트 사라짐
                <p>Stop</p>
            )}
            <button type='button' onClick={handleClick} >
                Toogle
            </button>
        </div>
    );
}
```

Timer 컴포넌트와 타이머 기능, 둘 다 없어지게 하려면? 함수를 리턴함으로써 종료 처리를 할 수 있다.

setInterval를 사용하는 경우에는 리턴할 때 id를 이용해서 clear를 해줘야 한다.

```tsx
function Timer() {
    useEffect(() => {
        console.log('Effect');

        // 제목을 저장해 놓는다.
        const savedTitle = document.title;

        // setTinterval id 받는다.
        const id = setInterval(() => {
            document.title = `Now: ${new Date().getTime()}`;
        }, 100);

        return () => {
            console.log('End of Effect');

            //setTinterval clear를 한다.
            clearInterval(id);

            // 저장한 제목으로 복원할 수 있다.
            document.title = savedTitle;
        };
    });

    return <p>Playing</p>;
}
```

### useEffect의 의존성 배열이란?

useEffect는 두 번째 인수로 의존성 배열을 갖는다.

* 아무것도 적지 않으면 무한동력 마냥 계속 실행된다.

* 처음 딱 한번만 실행하고 싶다면, 빈 배열을 넣으면 된다.

products처럼 데이터를 불러오는 상황에 사용한다.

```tsx
const [products, setProducts] = useState<Product[]>([]);
    useEffect(() => {
        const fetchProducts = async () => {
            const url = 'http://localhost:3002/products';
            const response = await fetch(url);
            const data = await response.json();
            setProducts(data.products);
    };

    fetchProducts();
}, []);
```

* 어떤 상태가 바뀔 때 실행하고 싶다면, 배열 안에 해당 상태를 넣으면 된다.

---- 여기서부터 다시 작성~ -----

## React StrictMode

개발 모드에서 혹시 모르는 문제를 찾기 위해서 사용한다.

라이프 사이클, 뭐 그런 것에 관련된 것을 두 번씩 실행해서 비교한다.

(라이프 사이클에서 ComponentDidMount과 같진 않지만 비슷하게) useEffect의 의존성 배열을 비워두고서 주의해라.

## 의존성 배열을 이용해 fetch 할 때 주의사항

먼저 실행해도 먼저 응답이 오지 않는다. 34분 30초

## 메모

추가 작성해야 할 내용

* 화살표 함수 22분 51초
* useEffect 클로저 30분 55초

[UI 런타임으로서의 React](https://overreacted.io/ko/react-as-a-ui-runtime/)
[useEffect 완벽 가이드](https://overreacted.io/ko/a-complete-guide-to-useeffect/)